//
//  DPPlugin.cpp
//  Smartface
//
//  Created by Faruk Toptas on 30.11.2013.
//  Copyright (c) 2013 Mobinex. All rights reserved.
//

#include "DPPlugin.h"
#include "SPJSDPPlugin.h"
#if defined (__APPLE__) && defined(SMARTFACE_PRODUCTION)
#include <iOSPlayer/JavaScriptCore/inc/JavaScriptCore.h>
#else
#include "inc/JavaScriptCore.h"
#endif
#include "DP4Capi.h"
#include <sstream>


static DPPlugin *dpPlugin = NULL;

DPPlugin* DPPlugin::getInstance(){  // singleton DPPlugin object
    if (dpPlugin == NULL){
        dpPlugin = new DPPlugin();
    }
    return dpPlugin;
}

DPPlugin::DPPlugin(){
#ifdef ANDROID_NDK
	pluginImpObject = 0;
	getBytes = 0;
	putBytes = 0;
#endif
}

DPPlugin::~DPPlugin(){
    
}




char* DPPlugin::getJSArrayString(JSContextRef ctx, JSObjectRef arrObject, const char* propertyName, const char* defaultValue)
{
    char* property = NULL;
    JSStringRef jspropertyName = JSStringCreateWithUTF8CString(propertyName);
    if(JSObjectHasProperty(ctx, arrObject, jspropertyName))
    {
        JSValueRef propertyValRef = JSObjectGetProperty(ctx, arrObject, jspropertyName, NULL);
        JSStringRef propertyString = JSValueToStringCopy(ctx, propertyValRef, NULL);
        size_t stringLen = JSStringGetMaximumUTF8CStringSize(propertyString);
        char* propertyBuffer = (char*)malloc(stringLen);
        JSStringGetUTF8CString(propertyString, propertyBuffer, stringLen);
        property = propertyBuffer;
        JSStringRelease(propertyString);
    }
    else
    {
        if(defaultValue)
        {
            property = strdup(defaultValue);
        }
    }
    JSStringRelease(jspropertyName);
    return property;
}


JSObjectRef DPPlugin::getJSArrayObject(JSContextRef ctx, JSObjectRef arrObject, const char* propertyName)
{
    JSObjectRef ret=NULL;
    JSStringRef jspropertyName = JSStringCreateWithUTF8CString(propertyName);
    if(JSObjectHasProperty(ctx, arrObject, jspropertyName))
    {
        JSValueRef propertyValRef = JSObjectGetProperty(ctx, arrObject, jspropertyName, NULL);
        ret = (JSObjectRef)propertyValRef;
    }
    JSStringRelease(jspropertyName);
    return ret;
}

bool DPPlugin::hasJSArrayProperty(JSContextRef ctx, JSObjectRef arrObject, const char* propertyName)
{
    bool ret = false;
    JSStringRef jspropertyName = JSStringCreateWithUTF8CString(propertyName);
    if(JSObjectHasProperty(ctx, arrObject, jspropertyName))
    {
        ret = true;
    }
    JSStringRelease(jspropertyName);
    return ret;
}

/*

 @desc activateOnlineWithFingerprint method. An activation is needed always
 
 @params 
 
    password - user password for activatingchar
    xfad - generated by the server
    xerc - generated by the server
    activationPassword - generated by the server
    nonce - random number
    platformFingerPrint - used for Digipass secrets encryption
 
*/
void DPPlugin::activateOnline(char* password, char* xfad, char* xerc, char* activationPassword, char* nonce, char* platformFingerprint){
    
    /* 
     static and dynamic vectors needed for each method.
     vectors creation and memory allocation
    */
    vds_int32 returnCode;
    vds_byte staticVector[LENGTH_STATIC_VECTOR_V8_MAX];
    vds_byte dynamicVector[LENGTH_DYNAMIC_VECTOR_V8_MAX];
    vds_int32 staticVectorLength    = sizeof(staticVector);
    vds_int32 dynamicVectorLength   = sizeof(dynamicVector);
    memset(staticVector, 0, staticVectorLength);
    memset(dynamicVector, 0, dynamicVectorLength);
    
    /*
     a DPPlugin instance is created
     argument object for callback methods is created
     a class is needed to generate callback data
    */
    DPPlugin *dp = DPPlugin::getInstance();
    JSValueRef args[] = {JSValueMakeNull(dp->jsContext)};
    JSClassRef cls = JSClassCreate(&spjsdata_def);
    
    
    returnCode = DPSDK_ActivateOnlineWithFingerprint(xfad, xerc, activationPassword, nonce, password, platformFingerprint, staticVector, &staticVectorLength, dynamicVector, &dynamicVectorLength);
    
    if (returnCode != RETURN_CODE_SUCCESS)  // an error occured, error message and error code is passed to error callback
    {
        printf("Online activation with encryption key FAILED - [%ld : %s] \n\n", returnCode, DPSDK_GetMessageForReturnCode(returnCode));
        if (dp->functionObjectMap[kActivateOnline_Error]) {
            args[0] = JSObjectMake(dp->jsContext, cls, (void**)generateErrorMessage(returnCode));
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kActivateOnline_Error], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kActivateOnline_Error]);
            dp->functionObjectMap[kActivateOnline_Error] = NULL;
        }
    }
    else
    {           // done! success callback is triggered
        printf("Online activation with fingerprint SUCCEEDED \n\n");
        
        /* static and dynamic vectors are output data for activation method. These vectors store activation data and needed for other methods.
            vectors are saved encrypted with secureSave method(SecureStorageSDK)
        */
        DPPlugin::secureSave(KEY_STATIC_VECTOR, staticVector, staticVectorLength);
        DPPlugin::secureSave(KEY_DYNAMIC_VECTOR, dynamicVector, dynamicVectorLength);
        /*
         Vectors lengths are being saved to documents folder. Don't need to be secure.
        */
        std::string tmpLength;
        std::stringstream tmpStreamS;
        std::stringstream tmpStreamD;
        tmpStreamS << staticVectorLength;
        tmpLength = tmpStreamS.str();

        DPPlugin::saveFileToDocuments(FILESTATICVECTORLENGTH, (char*)tmpLength.c_str(), tmpLength.length());
        tmpStreamD << dynamicVectorLength;
        tmpLength = tmpStreamD.str();
        DPPlugin::saveFileToDocuments(FILEDYNAMICVECTORLENGTH, (char*)tmpLength.c_str(), tmpLength.length());
        
        // success callback is triggered.
        if (dp->functionObjectMap[kActivateOnline_Success]) {
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kActivateOnline_Success], NULL, 0, NULL, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kActivateOnline_Success]);
            dp->functionObjectMap[kActivateOnline_Success] = NULL;
        }
    }

}

/*
 
 @desc activateOnlineWithFingerprint method. An activation is needed always
 
 @params
 
 password - activation password
 platformFingerPrint - used for Digipass secrets encryption
 
 */

void DPPlugin::validatePassword(char* pwd, char* platformFingerprint){
    
    /*
     static and dynamic vectors needed for each method.
     vectors creation and memory allocation
     the output parameter - encryptionKey-
     */
    vds_int32 returnCode = RETURN_CODE_STATUS_INVALID;
    vds_byte staticVector[LENGTH_STATIC_VECTOR_V8_MAX];
    vds_byte dynamicVector[LENGTH_DYNAMIC_VECTOR_V8_MAX];
    int staticVectorLength;
    int dynamicVectorLength;
    vds_byte encryptionKey[]		= {0x05, 0x02, 0x01, 0x00, 0x07, 0x03, 0x07, 0x08, 0x09, 0x03, 0x09, 0x02, 0x03, 0x04, 0x07, 0x09};
    vds_int32 encryptionKeyLength   = sizeof(encryptionKey);

    DPPlugin *dp = DPPlugin::getInstance();
    JSValueRef args[] = {JSValueMakeNull(dp->jsContext)};
    JSClassRef cls = JSClassCreate(&spjsdata_def);
    
    // vectors are read from storage
    bool read = readVectors(staticVector, &staticVectorLength, dynamicVector, &dynamicVectorLength);
    
    if (read) {
        returnCode = DPSDK_ValidatePasswordWithFingerprint(staticVector, staticVectorLength, dynamicVector, dynamicVectorLength, pwd, platformFingerprint, encryptionKey, encryptionKeyLength);
        
        // dynamic vector is changed, has to be saved.
        DPPlugin::secureSave(KEY_DYNAMIC_VECTOR, dynamicVector, dynamicVectorLength);
    }
    
    if (returnCode != RETURN_CODE_SUCCESS)      // an error occured, error message and error code is passed to error callback
    {
	    printf("The user password validation has FAILED - [%ld : %s] \n\n", returnCode, DPSDK_GetMessageForReturnCode(returnCode));
        if (dp->functionObjectMap[kValidatePassword_Error]) {
            args[0] = JSObjectMake(dp->jsContext, cls, (void**)generateErrorMessage(returnCode));
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kValidatePassword_Error], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kValidatePassword_Error]);
            dp->functionObjectMap[kValidatePassword_Error] = NULL;
        }
    }
    else    // done! success callback is triggered
    {
	    printf("The user password has been successfully validated.");
        if (dp->functionObjectMap[kValidatePassword_Success]) {
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kValidatePassword_Success], NULL, 0, NULL, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kValidatePassword_Success]);
            dp->functionObjectMap[kValidatePassword_Success] = NULL;
        }
    }
}


void DPPlugin::genereateOTP(char* pwd, char* timeShift, char* platformFingerprint){
    
    /*
     static and dynamic vectors needed for each method.
     vectors creation and memory allocation
     response and hostcode creation and memory allocation
     */
    vds_int32 returnCode = RETURN_CODE_STATUS_INVALID;
    vds_byte staticVector[LENGTH_STATIC_VECTOR_V8_MAX];
    vds_byte dynamicVector[LENGTH_DYNAMIC_VECTOR_V8_MAX];
    int staticVectorLength       = sizeof(staticVector);
    int dynamicVectorLength      = sizeof(dynamicVector);
    vds_ascii response[LENGTH_RESPONSE_MAX + 1];
    vds_ascii hostCode[LENGTH_HOST_CODE_MAX + 1];
    vds_int32 responseLength           = sizeof(response);
    vds_int32 hostCodeLength           = sizeof(hostCode);
    memset(response, 0, responseLength);
    memset(hostCode, 0, hostCodeLength);
    int clientServerTimeShift;
    sscanf(timeShift, "%d",&clientServerTimeShift);
    
    DPPlugin *dp = DPPlugin::getInstance();
    JSValueRef args[] = {JSValueMakeNull(dp->jsContext)};
    JSClassRef cls = JSClassCreate(&spjsdata_def);
    
    // vectors are read from storage
    bool read = readVectors(staticVector, &staticVectorLength, dynamicVector, &dynamicVectorLength);
    
    if(read) {
        returnCode = DPSDK_GenerateResponseOnly(staticVector, staticVectorLength, dynamicVector, dynamicVectorLength, pwd, clientServerTimeShift, CRYPTO_APPLICATION_INDEX_APP_1, platformFingerprint, response, responseLength, hostCode, hostCodeLength);
        
        // dynamic vector is changed, has to be saved.
        DPPlugin::secureSave(KEY_DYNAMIC_VECTOR, dynamicVector, dynamicVectorLength);
    }
    if (returnCode != RETURN_CODE_SUCCESS)  // an error occured, error message and error code is passed to error callback
    {
        printf("The password generation has FAILED - [%ld : %s] \n\n", returnCode, DPSDK_GetMessageForReturnCode(returnCode));
        if (dp->functionObjectMap[kGenerateOTP_Error]) {
            args[0] = JSObjectMake(dp->jsContext, cls, (void**)generateErrorMessage(returnCode));
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kGenerateOTP_Error], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kGenerateOTP_Error]);
            dp->functionObjectMap[kGenerateOTP_Error] = NULL;
        }
    }
    else    // done! success callback is triggered
    {
        printf("The password generation has SUCCEEDED \n");
        printf("OTP generated: %s \n", response);
        // otp is passed to callback object - e.otp
        if (dp->functionObjectMap[kGenerateOTP_Success]) {
            args[0] = JSObjectMake(dp->jsContext, cls, (void**)response);
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kGenerateOTP_Success], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kGenerateOTP_Success]);
            dp->functionObjectMap[kGenerateOTP_Success] = NULL;
        }
    }
}

void DPPlugin::changePassword(char* oldPwd, char* newPwd, char* platformFingerprint){
    
    /*
     static and dynamic vectors needed for each method.
     vectors creation and memory allocation
     */
    vds_int32 returnCode = RETURN_CODE_STATUS_INVALID;
    vds_byte staticVector[LENGTH_STATIC_VECTOR_V8_MAX];
    vds_byte dynamicVector[LENGTH_DYNAMIC_VECTOR_V8_MAX];
    int staticVectorLength       = sizeof(staticVector);
    int dynamicVectorLength      = sizeof(dynamicVector);
    
    DPPlugin *dp = DPPlugin::getInstance();
    JSValueRef args[] = {JSValueMakeNull(dp->jsContext)};
    JSClassRef cls = JSClassCreate(&spjsdata_def);
    
    // vectors are read from storage
    bool read = readVectors(staticVector, &staticVectorLength, dynamicVector, &dynamicVectorLength);
    
    if (read) {
        returnCode = DPSDK_ChangePasswordWithFingerprint(staticVector, staticVectorLength, dynamicVector, dynamicVectorLength, oldPwd, newPwd, platformFingerprint);
        
        // dynamic vector is changed, has to be saved.
        DPPlugin::secureSave(KEY_DYNAMIC_VECTOR, dynamicVector, dynamicVectorLength);
    }
    
    if (returnCode != RETURN_CODE_SUCCESS)      // an error occured, error message and error code is passed to error callback
    {
        printf("The user password was not changed - [%ld : %s] \n\n", returnCode, DPSDK_GetMessageForReturnCode(returnCode));
        if (dp->functionObjectMap[kChange_Password_Error]) {
            args[0] =JSObjectMake(dp->jsContext, cls, (void**)generateErrorMessage(returnCode));
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kChange_Password_Error], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kChange_Password_Error]);
            dp->functionObjectMap[kChange_Password_Error] = NULL;
        }
    }
    else    // done! success callback is triggered
    {
        printf("The user password has been successfully changed \n\n");
        if (dp->functionObjectMap[kChange_Password_Success]) {
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kChange_Password_Success], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kChange_Password_Success]);
            dp->functionObjectMap[kChange_Password_Success] = NULL;
        }
    }
    
}

void DPPlugin::generateDerivationCode(char* pwd, char* timeShift, char* platformFingerprint, char* challenge){
    
    /*
     static and dynamic vectors needed for each method.
     vectors creation and memory allocation
     */
    vds_int32 returnCode = RETURN_CODE_STATUS_INVALID;
    vds_byte staticVector[LENGTH_STATIC_VECTOR_V8_MAX];
    vds_byte dynamicVector[LENGTH_DYNAMIC_VECTOR_V8_MAX];
    vds_ascii derivationCode[LENGTH_DERIVATION_CODE_MAX + 1];
    vds_int32 derivationCodeLength  = LENGTH_DERIVATION_CODE_MAX + 1;
    int staticVectorLength       = sizeof(staticVector);
    int dynamicVectorLength      = sizeof(dynamicVector);
    memset(derivationCode, 0, derivationCodeLength);
    int clientServerTimeShift;
    sscanf(timeShift, "%d",&clientServerTimeShift);
    
    DPPlugin *dp = DPPlugin::getInstance();
    JSValueRef args[] = {JSValueMakeNull(dp->jsContext)};
    JSClassRef cls = JSClassCreate(&spjsdata_def);
    
    bool read = readVectors(staticVector, &staticVectorLength, dynamicVector, &dynamicVectorLength);
    
    if (read) {
        returnCode = DPSDK_GenerateDerivationCode(staticVector, staticVectorLength, dynamicVector, dynamicVectorLength, pwd, clientServerTimeShift, CRYPTO_APPLICATION_INDEX_APP_1, platformFingerprint, challenge, derivationCode, derivationCodeLength);
        
        // dynamic vector is changed, has to be saved.
        DPPlugin::secureSave(KEY_DYNAMIC_VECTOR, dynamicVector, dynamicVectorLength);
    }
    
    if (returnCode != RETURN_CODE_SUCCESS)      // an error occured, error message and error code is passed to error callback
    {
        printf("The derivation code generation has FAILED - [%ld : %s] \n\n", returnCode, DPSDK_GetMessageForReturnCode(returnCode));
        if (dp->functionObjectMap[kGenerateDerivationCode_Error]) {
            args[0] = JSObjectMake(dp->jsContext, cls, (void**)generateErrorMessage(returnCode));
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kGenerateDerivationCode_Error], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kGenerateDerivationCode_Error]);
            dp->functionObjectMap[kGenerateDerivationCode_Error] = NULL;
        }
    }
    else    // done! success callback is triggered
    {
        printf("The derivation code generation has SUCCEEDED \n");
        printf("derivation code generated: %s \n", derivationCode);
        // derivation code is passed to callback object - e.data
        if (dp->functionObjectMap[kGenerateDerivationCode_Success]) {
            args[0] = JSObjectMake(dp->jsContext, cls, (void**)derivationCode);
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kGenerateDerivationCode_Success], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kGenerateDerivationCode_Success]);
            dp->functionObjectMap[kGenerateDerivationCode_Success] = NULL;
        }
    }
}

void DPPlugin::getInfo(){
    
    /*
     static and dynamic vectors needed for each method.
     vectors creation and memory allocation
     */
    vds_int32 returnCode = RETURN_CODE_STATUS_INVALID;
    vds_byte staticVector[LENGTH_STATIC_VECTOR_V8_MAX];
    vds_byte dynamicVector[LENGTH_DYNAMIC_VECTOR_V8_MAX];
    int staticVectorLength       = sizeof(staticVector);
    int dynamicVectorLength      = sizeof(dynamicVector);
    
    DPPlugin *dp = DPPlugin::getInstance();
    JSValueRef args[] = {JSValueMakeNull(dp->jsContext)};
    JSClassRef cls = JSClassCreate(&spjsdata_def);
    
    // vectors are read from storage
    bool success = readVectors(staticVector, &staticVectorLength, dynamicVector, &dynamicVectorLength);
    if (!success) {
        if (dp->functionObjectMap[kGetInfo_Error]) {
            args[0] =JSObjectMake(dp->jsContext, cls, (void**)generateErrorMessage(returnCode));
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kGetInfo_Error], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kGetInfo_Error]);
            dp->functionObjectMap[kGetInfo_Error] = NULL;
        }
        return;
    }
    
    vds_byte version;
    vds_byte passwordFatalCounter;
    vds_byte status;
    vds_word32 appEventCounter;
    
    int serialLength = LENGTH_SERIAL_NUMBER + 1;
    vds_ascii serial[serialLength];
    memset(serial, 0, serialLength);
    DPInfo *info = new DPInfo();

    returnCode = DPSDK_GetDigipassProperty(staticVector, staticVectorLength, dynamicVector, dynamicVectorLength, PROPERTY_SERIAL_NUMBER, serial, serialLength, CRYPTO_APPLICATION_INDEX_APP_1);
    if (returnCode != RETURN_CODE_SUCCESS){     // an error occured, error message and error code is passed to error callback
        if (dp->functionObjectMap[kGetInfo_Error]) {
            args[0] =JSObjectMake(dp->jsContext, cls, (void**)generateErrorMessage(returnCode));
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kGetInfo_Error], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kGetInfo_Error]);
            dp->functionObjectMap[kGetInfo_Error] = NULL;
        }
    }else{
        info->serial = serial;
        
        returnCode = DPSDK_GetDigipassProperty(staticVector, staticVectorLength, dynamicVector,
                                                         dynamicVectorLength, PROPERTY_VERSION, &version, sizeof(version), CRYPTO_APPLICATION_INDEX_APP_1);
        
        if (returnCode != RETURN_CODE_SUCCESS)
        {
            printf("Error while getting the DIGIPASS properties - [%li : %s] \n\n", returnCode,
                   DPSDK_GetMessageForReturnCode(returnCode));
        }
        else
        {
            info->version = version;
            
            returnCode = DPSDK_GetDigipassProperty(staticVector, staticVectorLength, dynamicVector,
                                                            dynamicVectorLength, PROPERTY_STATUS, &status, sizeof(status), CRYPTO_APPLICATION_INDEX_APP_1);
            
            
            if (returnCode != RETURN_CODE_SUCCESS)
            {
                printf("Error while getting the DIGIPASS properties - [%li : %s] \n\n", returnCode,
                       DPSDK_GetMessageForReturnCode(returnCode));
            }
            else
            {
                info->status = status;
                
                returnCode = DPSDK_GetDigipassProperty(staticVector, staticVectorLength, dynamicVector,
                                                       dynamicVectorLength, PROPERTY_PASSWORD_FATAL_COUNTER, &passwordFatalCounter, sizeof(passwordFatalCounter), CRYPTO_APPLICATION_INDEX_APP_1);
                if (returnCode != RETURN_CODE_SUCCESS)
                {
                    printf("Error while getting the DIGIPASS properties - [%li : %s] \n\n", returnCode,
                           DPSDK_GetMessageForReturnCode(returnCode));
                }
                else
                {
                    info->fatalCounter = passwordFatalCounter;
                    
                    returnCode = DPSDK_GetDigipassProperty(staticVector, staticVectorLength, dynamicVector,
                                                           dynamicVectorLength, PROPERTY_APP_EVENT_COUNTER, &appEventCounter, sizeof(appEventCounter), CRYPTO_APPLICATION_INDEX_APP_1);
                    if (returnCode != RETURN_CODE_SUCCESS)
                    {
                        info->appEventCounter = -1;
                        printf("Error while getting the DIGIPASS properties - [%li : %s] \n\n", returnCode, DPSDK_GetMessageForReturnCode(returnCode));
                    }
                    else
                    {
                        info->appEventCounter = appEventCounter;
                    }
                }
            }
        }
        
        // done! success callback is triggered
        if (dp->functionObjectMap[kGetInfo_Success]) {
            args[0] =JSObjectMake(dp->jsContext, cls, (void**)info);
            JSObjectCallAsFunction(dp->jsContext, dp->functionObjectMap[kGetInfo_Success], NULL, 1, args, NULL);
            unProtectCallbackOnMainThread(dp->functionObjectMap[kGetInfo_Success]);
            dp->functionObjectMap[kGetInfo_Success] = NULL;
        }
    }
}

int DPPlugin::computeTimeShift(char *serverTime){
    int shift;
    sscanf(serverTime, "%d",&shift);
    return DPSDK_ComputeClientServerTimeShiftFromServerTime(shift);
}

// reads static and dynamic vector from local storage
bool DPPlugin::readVectors(vds_byte* staticVector, int* staticVectorLength,vds_byte* dynamicVector, int* dynamicVectorLength){
    bool success = false;
    char* tmpStatic = DPPlugin::secureRead(KEY_STATIC_VECTOR);
    char* tmpStaticLen = DPPlugin::readFileFromDocuments(FILESTATICVECTORLENGTH);
    char* tmpDynamic = DPPlugin::secureRead(KEY_DYNAMIC_VECTOR);
    char* tmpDynamicLen = DPPlugin::readFileFromDocuments(FILEDYNAMICVECTORLENGTH);
    if (tmpStatic != NULL && tmpStaticLen != NULL && tmpDynamic != NULL && tmpDynamicLen != NULL){
        sscanf(tmpStaticLen, "%d", staticVectorLength);
        memset(staticVector,0,LENGTH_STATIC_VECTOR_V8_MAX);
        memcpy(staticVector, tmpStatic, *staticVectorLength);

        sscanf(tmpDynamicLen, "%d", dynamicVectorLength);
        memset(dynamicVector,0,LENGTH_DYNAMIC_VECTOR_V8_MAX);
        memcpy(dynamicVector, tmpDynamic, *dynamicVectorLength);
        success = true;
    }
    else {
        success = false;
        dynamicVectorLength = 0;
        staticVectorLength = 0;
    }
    if (tmpStaticLen) free(tmpStaticLen);
    if (tmpDynamicLen) free(tmpDynamicLen);
    
    return success;
}

// generates error message from return code
const char* DPPlugin::generateErrorMessage(int errorCode){
    vds_ascii* message = DPSDK_GetMessageForReturnCode(errorCode) ;
    int len = strlen(message) + 20;
    char *buf = (char *)calloc(len, sizeof(char));
    sprintf(buf, "%s %d", message ? message : "", errorCode);
	return buf;
}

#ifdef ANDROID_NDK

void DPPlugin::protectCallbackOnMainThread(JSObjectRef objectRef) {
    JSValueProtect(jsContext, objectRef);
}

void DPPlugin::unProtectCallbackOnMainThread(JSObjectRef objectRef) {
    JSValueUnprotect(jsContext, objectRef);
}

#endif
